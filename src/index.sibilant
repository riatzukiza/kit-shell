
(macro set-globals (...body)
       `(mixin (lit ...@body) global))
(include "kit/header")
(import-namespace kit)


(require! 'fs 'sibilant 'readline)

(include "kit-repl/header")
(import-namespace repl)


(.include sibilant "kit/header" )
(.include sibilant "kit-loader/index")
(.include sibilant (.resolve require "./meta"))
(.include sibilant "kit-interface/header")

(set module 'filename (pipe (process.cwd) ))

(when (.exists-sync fs "./.sibilant/meta.sibilant")
  (.include sibilant "./.sibilant/meta"))

(require! Path 'path)

(set-globals (sibilant (require 'sibilant))
             (R (require 'ramda))
             process
             module
             exports
             (def require (module-path)
               (require (if (= (first module-path) ".")
                            (.join Path (process.cwd) module-path))
                        module-path))
             create extend mixin conditional cond partially-apply-after
             )

(var rl-config )
(def-curried append-line (path d)
  (append-file path (+ d "\n")))
(def-curried append-file (path d)
  (make-promise
   (.append-file fs path d (=> (e) (if e (fail e) (success))))))
(var history-file-path "./history.sibilant")

(def read-history (actor)
  (print "reading history")
  )

(let ((repl (.start ((create REPL))))
      (rl (.create-interface
           readline
           (lit (input process.stdin)
                (output process.stdout)
                (prompt "#>")))))

  (pipe (append-file history-file-path "")
        (then-do (make-promise
                  (pipe (.create-read-stream fs history-file-path)
                        (.on  'data (#-> (+ "") repl.send))
                        (.on 'data (aprint))
                        (.on  'end success)
                        (.on  'error fail))))
        (then-do (pipe rl
                       (.on  'line (#-> repl.send))

                       (.on 'line (append-line history-file-path)))
                 (.on repl 'result (#-> rl.prompt))
                 (.prompt rl)))

  (pipe repl
        (.on  'result (aprint "result:"))
        (.on  'error (aprint "error:"))
        (.on  'log (aprint "log:")))

  (print "awaiting input")
  )



